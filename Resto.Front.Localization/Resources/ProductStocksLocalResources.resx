<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="WriteoffAllButtonText" xml:space="preserve">
    <value>Списать все</value>
  </data>
  <data name="ProductBatchExpirationTimerFormatMinutesSeconds" xml:space="preserve">
    <value>{0}:{1:D2}</value>
  </data>
  <data name="ProductBatchExpirationTimerFormatHoursMinutesSeconds" xml:space="preserve">
    <value>{0}:{1:D2}:{2:D2}</value>
  </data>
  <data name="CookAction" xml:space="preserve">
    <value>Приготовить</value>
  </data>
  <data name="WriteoffAction" xml:space="preserve">
    <value>Списать</value>
  </data>
  <data name="EditCookAction" xml:space="preserve">
    <value>Редактировать приготовление</value>
  </data>
  <data name="LastCookInfoTemplate" xml:space="preserve">
    <value>Приготовление в {0:HH:mm} — {1} {2}.</value>
    <comment>Пример: «Приготовление в 19:25 — 5 порц.»</comment>
  </data>
  <data name="EditWriteoffAction" xml:space="preserve">
    <value>Редактировать списание</value>
  </data>
  <data name="LastWriteoffInfoTemplate" xml:space="preserve">
    <value>Списание в {0:HH:mm} — {1} {2}.</value>
    <comment>Пример: «Списание в 08:43 — 17 кг.»</comment>
  </data>
  <data name="ProductStockActionsViewTitle" xml:space="preserve">
    <value>Количество</value>
  </data>
  <data name="CookActionProgressText" xml:space="preserve">
    <value>Приготовление...</value>
  </data>
  <data name="WriteoffActionProgressText" xml:space="preserve">
    <value>Списание...</value>
  </data>
  <data name="CookActionMessageTitle" xml:space="preserve">
    <value>Приготовление</value>
  </data>
  <data name="CookActionZeroAmountMessage" xml:space="preserve">
    <value>Введите количество блюд в партии.</value>
  </data>
  <data name="WriteoffActionMessageTitle" xml:space="preserve">
    <value>Списание</value>
  </data>
  <data name="WriteoffActionZeroAmountMessage" xml:space="preserve">
    <value>Введите количество списываемых блюд.</value>
  </data>
  <data name="EditInfoOutdatedMessageFormat" xml:space="preserve">
    <value>Редактирование возможно только в течение {0} минут
после ввода приготовления/списания
или их последнего редактирования.</value>
    <comment>{0} — продолжительность периода в минутах, в течение которого допускается редактирование приготовления/списания (по умолчанию 15 минут, допустимый интервал 1..60 минут)</comment>
  </data>
  <data name="NotEnoughProductAmountToEditCookedBatchMessageTemplate" xml:space="preserve">
    <value>Если приготовленное количество блюда в партии станет меньше {0},
то остатки по партии будут отрицательными.
При редактировании укажите количество от {0}.</value>
  </data>
  <data name="NotEnoughProductAmountToWriteoffMessageTemplate" xml:space="preserve">
    <value>Если списать указанное количество блюда,
то остатки по блюду будут отрицательными.
При списании укажите количество до {0}.</value>
  </data>
  <data name="NotEnoughProductAmountToEditWriteoffMessageTemplate" xml:space="preserve">
    <value>Если списанное количество блюда станет больше {0},
то остатки по блюду будут отрицательными.
При редактировании укажите количество до {0}.</value>
  </data>
  <data name="ProductNotMaintainedMessage" xml:space="preserve">
    <value>Учет запасов блюда «{0}» не ведется.</value>
    <comment>{0} — название блюда</comment>
  </data>
  <data name="UpdateWeightButtonText" xml:space="preserve">
    <value>Весы</value>
  </data>
  <data name="WeightUpdateMessage" xml:space="preserve">
    <value>Получение данных с весов</value>
  </data>
  <data name="InvalidProductWeight" xml:space="preserve">
    <value>Количество товара не должно превышать {0}.</value>
  </data>
  <data name="PriceTicketPrintRequired" xml:space="preserve">
    <value>Печать этикетки</value>
    <comment>Текст для залипающей кнопки. Если кнопка нажата, при нажатии ОК в диалоге будет напечатана этикетка.</comment>
  </data>
  <data name="ServerConnectionFailedMessage" xml:space="preserve">
    <value>Не удалось установить соединение с сервером контроля заготовок.
Повторите попытку позже.</value>
  </data>
  <data name="WriteoffAllConfirmationMessage" xml:space="preserve">
    <value>Вы действительно хотите списать все блюда?</value>
  </data>
  <data name="EditInfoOverwrittenMessage" xml:space="preserve">
    <value>На другом терминале введено или отредактировано приготовление/списание.
Данные будут обновлены.</value>
  </data>
  <data name="CannotWriteoffProductMessageTemplate" xml:space="preserve">
    <value>Списание невозможно: количество блюда изменилось, остаток равен нулю.</value>
  </data>
  <data name="InvalidCookingPlaceMapSettingsMessageFormat" xml:space="preserve">
    <value>Списание «{0}» невозможно: в настройках группы «{1}» не указано место приготовления для «{2}».</value>
    <comment>{0} — название продукта, {1} — название заготовочной группы отделений, {2} — название типа места приготовления продукта</comment>
  </data>
  <data name="InvalidCookingPlaceStoreSettingsMessageFormat" xml:space="preserve">
    <value>Списание «{0}» невозможно: в настройках отделения «{1}» не указан склад.</value>
    <comment>{0} — название продукта, {1} — название отделения, где этот продукт готовится</comment>
  </data>
  <data name="InvalidCookingPlaceTypeSettingsMessageFormat" xml:space="preserve">
    <value>Списание «{0}» невозможно: у продукта не задан тип места приготовления.</value>
    <comment>{0} — название продукта</comment>
  </data>
  <data name="MenuButtonProductBatchExpirationTimerGreaterThanXMinutes" xml:space="preserve">
    <value>&gt; {0} м</value>
  </data>
  <data name="MenuButtonProductBatchExpirationTimerLessThanXMinutes" xml:space="preserve">
    <value>&lt; {0} м</value>
  </data>
  <data name="MenuButtonProductBatchExpirationTimer" xml:space="preserve">
    <value>{0} м</value>
  </data>
  <data name="TooLargeAmountToPrintBarcode" xml:space="preserve">
    <value>Количество больше {0}, этикетка будет распечатана без штрихкода</value>
  </data>
  <data name="InvalidArticleToPrintBarcode" xml:space="preserve">
    <value>Количество знаков в артикуле не равно {0}, этикетка будет распечатана без штрихкода</value>
  </data>
  <data name="NoPriceTicketForZeroAmount" xml:space="preserve">
    <value>Для нулевого количества этикетка распечатана не будет</value>
  </data>
</root>